<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>利用社交网络数据 - 推荐系统</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">推荐系统</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="利用社交网络数据"><a class="header" href="#利用社交网络数据">利用社交网络数据</a></h1>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%94%E5%BE%84">获取社交网络数据的途径</a></li>
<li><a href="#%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B">社交网络数据简介</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E8%8D%90">基于社交网络的推荐</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E9%82%BB%E5%9F%9F%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95">基于邻域的社会化推荐算法</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%8C%96%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95">基于图的社会化推荐算法</a></li>
<li><a href="#%E5%AE%9E%E9%99%85%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%A4%BE%E4%BC%9A%E5%8C%96%E6%8E%A8%E8%8D%90">实际系统中的社会化推荐</a></li>
<li><a href="#%E7%A4%BE%E4%BC%9A%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">社会化推荐系统和协同过滤推荐系统</a></li>
<li><a href="#%E4%BF%A1%E6%81%AF%E6%B5%81%E6%8E%A8%E8%8D%90">信息流推荐</a></li>
</ul>
</li>
<li><a href="#%E7%BB%99%E7%94%A8%E6%88%B7%E6%8E%A8%E8%8D%90%E5%A5%BD%E5%8F%8B">给用户推荐好友</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E5%8C%B9%E9%85%8D">基于内容的匹配</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%85%B1%E5%90%8C%E5%85%B4%E8%B6%A3%E7%9A%84%E5%A5%BD%E5%8F%8B%E6%8E%A8%E8%8D%90">基于共同兴趣的好友推荐</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%9A%84%E5%A5%BD%E5%8F%8B%E6%8E%A8%E8%8D%90">基于社交网络图的好友推荐</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E8%B0%83%E6%9F%A5%E7%9A%84%E5%A5%BD%E5%8F%8B%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94">基于用户调查的好友推荐算法对比</a></li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
</ul>
<p>自从搜索引擎谷歌诞生后，大家都在讨论互联网的下一个金矿是什么。现在，几乎所有的人都认为那就是社交网络。根据尼尔森2010年的报告，用户在互联网上22%的时间花费在社交网站和社交媒体上。Facebook和Twitter作为两种不同类型社交网络的代表，是目前互联网界的宠儿。谷歌公司也不甘落后，连续推出了很多社交网络产品（Buzz和Google  Plus）。国内的互联网以新浪微博为代表，也吸引了很多人的眼球。</p>
<p>基于社交网络的推荐可以很好地模拟现实社会。在现实社会中，很多时候我们都是通过朋友获得推荐。美国著名的第三方调查机构尼尔森调查了影响用户相信某个推荐的因素。调查结果显示，90%的用户相信朋友对他们的推荐，70%的用户相信网上其他用户对广告商品的评论。从该调查可以看到，好友的推荐对于增加用户对推荐结果的信任度非常重要。</p>
<p>为了进一步证实好友推荐对用户的影响，尼尔森和Facebook合作进行了一次个性化广告实验。尼尔森测试了同一个品牌的3种不同形式的广告。第一种广告和第二种广告都是图片广告，但两者的推荐理由不同。第一种广告的推荐理由没有社会化信息，仅仅是表示该品牌受到了51  930个用户的关注，而第二种广告的推荐理由是用户的某些好友关注了这个广告。第三种广告比较特别，它是在用户的好友关注该品牌时，就在用户的信息流中加入一条信息，告诉用户他的某个好友关注了一个品牌。通过在线AB测试，尼尔森发现第三种广告的效果明显高于第二种，而第二种广告的效果明显高于第一种，从而证明了社会化推荐对于增加用户对广告的印象和购买意愿具有非常强烈的作用。同时，该实验也从侧面说明社交网络在推荐系统中可能具有重要的作用。</p>
<p>本章将详细讨论如何利用社交网络数据给用户进行个性化推荐。本章不仅讨论如何利用社交网络给用户推荐物品，而且将讨论如何利用社交网络给用户推荐好友。</p>
<h2 id="获取社交网络数据的途径"><a class="header" href="#获取社交网络数据的途径">获取社交网络数据的途径</a></h2>
<p>现在互联网上充斥着各种各样带有社交性质的网站。那么，从什么方面可以获得社交网络数据呢？一般来说，有如下方式。</p>
<ol>
<li>电子邮件</li>
<li>用户注册信息</li>
<li>用户的位置数据</li>
<li>论坛和讨论组</li>
<li>即时聊天工具</li>
<li>社交网络</li>
</ol>
<p>上述各种获取用户社交关系的途径，要么就是因为隐私问题很难获取，要么就是虽然容易获取，但却都是隐性社交关系数据，很难推断出用户之间的显性社交关系。在Facebook和Twitter诞生之前，社会化应用（无论是电子邮件系统还是即时聊天系统）都过于封闭。用户只能和自己的好友进行交流，而无法了解到好友圈以外的世界，而且用户之间交流的内容都是非常私密的，大部分用户不会允许将它们公开来用作其他用途。</p>
<p>但以Facebook和Twitter为代表的新一代社交网络突破了这个瓶颈。它们允许用户创建一个公开的页面介绍自己，并且默认公开用户的好友列表（当然用户可以指定不将某些好友公开，但如果用户不指定，默认是公开的），而用户基于它们讨论的话题也很少涉及个人隐私，大都是讨论一些社会热点或分享一些图片、音乐、视频和笑话。</p>
<p>社交网站的另一个好处是自然地减轻了信息过载问题。在社交网站中，我们可以通过好友给自己过滤信息。比如，我们只关注那些和我们兴趣相似的好友，只阅读他们分享的信息，因此可以避免阅读很多和自己无关的信息。个性化推荐系统可以利用社交网站公开的用户社交网络和行为数据，辅助用户更好地完成信息过滤的任务，更好地找到和自己兴趣相似的好友，更快地找到自己感兴趣的内容。</p>
<ol>
<li>社会图谱和兴趣图谱</li>
</ol>
<p>Facebook和Twitter作为社交网站中的两个代表，它们其实代表了不同的社交网络结构。在Facebook里，人们的好友一般都是自己在现实社会中认识的人，比如亲戚、同学、同事等，而且Facebook中的好友关系是需要双方确认的。在Twitter里，人们的好友往往都是现实中自己不认识的，而只是出于对对方言论的兴趣而建立好友关系，好友关系也是单向的关注关系。以Facebook为代表的社交网络称为社交图谱（social  graph），而以Twitter为代表的社交网络称为兴趣图谱（interest graph）。</p>
<p>关于这两种社交网络的分类其实早在19世纪就被社会学家研究过了。19世纪，德国社会学家斐迪南·滕尼斯（Ferdinand  Tönnies）认为社会群体分为两种，一种是通过人们之间的共同兴趣和信念形成的，他将这种社会群体称为Gemeinschaft，而Gemeinschaft这个词后来被翻译成英语就是community，即汉语中的社区。另一种社会群体则是由于人们之间的亲属关系，工作关系而形成的，他称之为Gesellschaft，英文翻译为society，即汉语中的“社会”。因此，斐迪南·滕尼斯说的Gemeinschaft就是兴趣图谱，而Gesellschaft就是社会图谱。但是，每个社会化网站都不是单纯的社交图谱或者兴趣图谱。一般认为，Facebook中的绝大多数用户联系基于社交图谱，而Twitter中的绝大多数用户联系基于兴趣图谱。</p>
<p>但是，在Twitter或者微博中，我们也会关注现实中的亲朋好友，在Facebook中我们也会和一部分好友有同样的兴趣。</p>
<h2 id="社交网络数据简介"><a class="header" href="#社交网络数据简介">社交网络数据简介</a></h2>
<p>社交网络定义了用户之间的联系，因此可以用图定义社交网络。我们用图<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>定义一个社交网络，其中V是顶点集合，每个顶点代表一个用户，E是边集合，如果用户va和vb有社交网络关系，那么就有一条边<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>连接这两个用户，而<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>定义了边的权重。业界有两种著名的社交网络。一种以Facebook为代表，它的朋友关系是需要双向确认的，因此在这种社交网络上可以用无向边连接有社交网络关系的用户。另一种以Twitter为代表，它的朋友关系是单向的，因此可以用有向边代表这种社交网络上的用户关系。</p>
<p>此外，对图G中的用户顶点u，定义out(u)为顶点u指向的顶点集合（如果套用微博中的术语，out(u)就是用户u关注的用户集合），定义in(u)为指向顶点u的顶点集合（也就是关注用户u的用户集合）。那么，在Facebook这种无向社交网络中显然有out(u)=in(u)。</p>
<p>一般来说，有3种不同的社交网络数据。</p>
<p>双向确认的社交网络数据 在以Facebook和人人网为代表的社交网络中，用户A和B之间形成好友关系需要通过双方的确认。因此，这种社交网络一般可以通过无向图表示。</p>
<p>单向关注的社交网络数据 在以Twitter和新浪微博为代表的社交网络中，用户A可以关注用户B而不需要得到用户B的允许，因此这种社交网络中的用户关系是单向的，可以通过有向图表示。</p>
<p>基于社区的社交网络数据  还有一种社交网络数据，用户之间并没有明确的关系，但是这种数据包含了用户属于不同社区的数据。比如豆瓣小组，属于同一个小组可能代表了用户兴趣的相似性。或者在论文数据集中，同一篇文章的不同作者也存在着一定的社交关系。或者是在同一家公司工作的人，或是同一个学校毕业的人等。</p>
<p>社交网络数据中的长尾分布</p>
<p>和前面第2章提到的用户活跃度分布和物品流行度分布类似，社交网络中用户的入度（in degree）和出度（out degree）的分布也是满足长尾分布的。</p>
<h2 id="基于社交网络的推荐"><a class="header" href="#基于社交网络的推荐">基于社交网络的推荐</a></h2>
<p>很多网站都利用Facebook的社交网络数据给用户提供社会化推荐。</p>
<p>社会化推荐之所以受到很多网站的重视，是缘于如下优点。</p>
<p>好友推荐可以增加推荐的信任度  好友往往是用户最信任的。用户往往不一定信任计算机的智能，但会信任好朋友的推荐。同样是给用户推荐《天龙八部》，前面提到的基于物品的协同过滤算法会说是因为用户之前看过《射雕英雄传》，而好友推荐会说是因为用户有8个好友都非常喜欢《天龙八部》。对比这两种解释，第二种解释一般能让用户更加心动，从而购买或者观看《天龙八部》。</p>
<p>社交网络可以解决冷启动问题  当一个新用户通过微博或者Facebook账号登录网站时，我们可以从社交网站中获取用户的好友列表，然后给用户推荐好友在网站上喜欢的物品。从而我们可以在没有用户行为记录时就给用户提供较高质量的推荐结果，部分解决了推荐系统的冷启动问题。</p>
<p>当然，社会化推荐也有一些缺点，其中最主要的就是很多时候并不一定能提高推荐算法的离线精度（准确率和召回率）。特别是在基于社交图谱数据的推荐系统中，因为用户的好友关系不是基于共同兴趣产生的，所以用户好友的兴趣往往和用户的兴趣并不一致。比如，我们和自己父母的兴趣往往就差别很大。不过，因为社会化推荐算法不一定能提供离线精度，而且包含社交网络数据和用户行为数据的数据集不太多，因此本章不准备通过离线实验证明社会化推荐的优势。2</p>
<p>010年，ACM推荐系统大会的一个讨论组CAMRa曾经举办过一个关于社交网络的推荐系统比赛。该比赛希望参赛者能够利用用户之间的好友关系给用户推荐电影，并且利用准确率相关的指标评测参赛者的推荐算法。对社会化推荐感兴趣的读者可以关注一下该会议的相关论文。</p>
<h3 id="基于邻域的社会化推荐算法"><a class="header" href="#基于邻域的社会化推荐算法">基于邻域的社会化推荐算法</a></h3>
<p>如果给定一个社交网络和一份用户行为数据集。其中社交网络定义了用户之间的好友关系，而用户行为数据集定义了不同用户的历史行为和兴趣数据。那么我们想到的最简单算法是给用户推荐好友喜欢的物品集合。</p>
<h3 id="基于图的社会化推荐算法"><a class="header" href="#基于图的社会化推荐算法">基于图的社会化推荐算法</a></h3>
<p>前几章都提到了如何在推荐系统中使用图模型，比如用户物品二分图、用户-物品-标签图模型等。从前面几章的介绍可以看到，图模型的优点是可以将各种数据和关系都表示到图上去。在社交网站中存在两种关系，一种是用户对物品的兴趣关系，一种是用户之间的社交网络关系。本节主要讨论如何将这两种关系建立到图模型中，从而实现对用户的个性化推荐。</p>
<p>用户的社交网络可以表示为社交网络图，用户对物品的行为可以表示为用户物品二分图，而这两种图可以结合成一个图。</p>
<h3 id="实际系统中的社会化推荐"><a class="header" href="#实际系统中的社会化推荐">实际系统中的社会化推荐</a></h3>
<p>前面提到的基于邻域的社会化推荐算法看起来非常简单，但在实际系统中却是很难操作的，这主要是因为该算法需要拿到用户所有好友的历史行为数据，而这一操作在实际系统中是比较重的操作。因为大型网站中用户数目非常庞大，用户的历史行为记录也非常庞大，所以不太可能将用户的所有行为都缓存在内存中，只能在数据库前做一个热数据的缓存。而如果我们需要比较实时的数据，这个缓存中的数据就要比较频繁地更新，因而避免不了数据库的查询。我们知道，数据库查询一般是很慢的，特别是针对行为很多的用户更是如此。所以，如果一个算法再给一个用户做推荐时，需要他所有好友的历史行为数据，这在实际环境中是比较困难的。</p>
<p>如果回想一下ItemCF可以发现，ItemCF算法只需要当前用户的历史行为数据和物品的相关表就可以生成推荐结果。对于物品数不是特别多的网站，可以很容易地将物品相关表缓存在内存中，因此查询相关物品的代价很低，所以ItemCF算法很容易在实际环境下实现。</p>
<p>当然，我们可以从几个方面改进基于邻域的社会化推荐算法，让它能够具有比较快的响应时间。改进的方向有两种，一种是治标不治本的方法。简单地说，就是可以做两处截断。第一处截断就是在拿用户好友集合时并不拿出用户所有的好友，而是只拿出和用户相似度最高的N个好友。这里N可以取一个比较小的数。从而给该用户做推荐时可以只查询N次用户历史行为接口。此外，在查询每个用户的历史行为时，可以只返回用户最近1个月的行为，这样就可以在用户行为缓存中缓存更多用户的历史行为数据，从而加快查询用户历史行为接口的速度。此外，还可以牺牲一定的实时性，降低缓存中用户行为列表过期的频率。</p>
<p>而第二种解决方案需要重新设计数据库。通过前面的分析可以发现，社会化推荐中关键的操作就是拿到用户所有好友的行为数据，然后通过一定的聚合展示给用户。如果对照一下微博，我们就可以发现微博中每个用户都有一个信息墙，这个墙上实时展示着用户关注的所有好友的动态。因此，如果能够实现这个信息墙，就能够实现社会化推荐算法。Twitter的解决方案是给每个用户维护一个消息队列（message queue），当一个用户发表一条微博时，所有关注他的用户的消息队列中都会加入这条微博。这个实现的优点是用户获取信息墙时可以直接读消息队列，所以终端用户的读操作很快。不过这个实现也有缺点，当一个用户发表了一条微博，就会触发很多写操作，因为要更新所有关注他的用户的消息队列，特别是当一个人被很多人关注时，就会有大量的写操作。Twitter通过大量的缓存解决了这一问题。具体的细节可以参考InfoQ对Twitter架构的介绍。</p>
<p>如果将Twitter的架构搬到社会化推荐系统中，我们就可以按照如下方式设计系统：</p>
<p>首先，为每个用户维护一个消息队列，用于存储他的推荐列表；</p>
<p>当一个用户喜欢一个物品时，就将（物品ID、用户ID和时间）这条记录写入关注该用户的推荐列表消息队列中；</p>
<p>当用户访问推荐系统时，读出他的推荐列表消息队列，对于这个消息队列中的每个物品，重新计算该物品的权重。计算权重时需要考虑物品在队列中出现的次数，物品对应的用户和当前用户的熟悉程度、物品的时间戳。同时，计算出每个物品被哪些好友喜欢过，用这些好友作为物品的推荐解释。</p>
<h3 id="社会化推荐系统和协同过滤推荐系统"><a class="header" href="#社会化推荐系统和协同过滤推荐系统">社会化推荐系统和协同过滤推荐系统</a></h3>
<p>关于社会化推荐系统的离线评测可以参考Georg Groh和Christian Ehmig的工作成果。不过社会化推荐系统的效果往往很难通过离线实验评测，因为社会化推荐的优势不在于增加预测准确度，而是在于通过用户的好友增加用户对推荐结果的信任度，从而让用户单击那些很冷门的推荐结果。此外，很多社交网站（特别是基于社交图谱的社交网站）中具有好友关系的用户并不一定有相似的兴趣。因此，利用好友关系有时并不能增加离线评测的准确率和召回率。因此，很多研究人员利用用户调查和在线实验的方式评测社会化推荐系统。</p>
<p>对社会化推荐系统进行用户调查的代表性工作成果是Rashmi  Sinha和Kirsten  Swearingen对比社会化推荐系统和协同过滤推荐系统的论文。这一节将简单介绍一下他们的工作方法和结果。</p>
<p>一共有19个人参加了实验，他们都来自加州大学伯克利分校，年龄为20~35岁，其中6名男性13名女性，9名实验人员从事互联网技术相关的工作，而剩下10位从事的工作和互联网技术无关。Sinha首先让他们进行第一项任务：评测3个真实的电影推荐系统（Amazon、MovieCritic、Reel.co）和3个真实的图书推荐系统（Amazon.com、 RatingZone、 Sleeper）。在评测每一个真实推荐系统时，参试者需要按照如下顺序完成实验。</p>
<p>利用一个虚假的邮箱注册推荐系统，从而保证这些新账号没有任何历史行为。</p>
<p>利用新注册的账号给电影、图书进行评分。</p>
<p>查看推荐列表。</p>
<p>如果一开始的推荐列表中没有符合用户兴趣的物品，用户将被要求从该网站中搜索到至少一个令他们感兴趣的物品，如果实在找不到，可以停止搜索。</p>
<p>回答调查问卷。在完成真实推荐系统的评测任务后，参试者还需要评测社会化推荐系统。</p>
<p>实验步骤如下。</p>
<p>每个参试者需要提供3个他们认为了解其兴趣的好友的邮箱。</p>
<p>实验人员给每个好友发邮件，要求他们给参试者推荐3本书和3部电影，并且要求这些书和电影不能是参试者之前和他们讨论过的，即不能是参试者之前告诉他们并表示喜欢的物品。</p>
<p>参试者将会看到好友推荐的书和电影的缩略图以及一段简单的介绍。</p>
<p>回答调查问卷。作者通过分析用户实验的过程和最终回答的调查问卷证明，社会化推荐系统推荐结果的用户满意度明显高于主要基于协同过滤算法的几个真实推荐系统。具体的数据可以参考作者的论文。这里仅引用亚马逊网的图书推荐和好友推荐的结果对比。60%的参试者认为亚马逊网的图书推荐是好的推荐，32%的参试者认为亚马逊网的图书推荐是有用的推荐。与之形成对比的是，90%的参试者认为好友的图书推荐是好的推荐，78%的参试者认为好友的图书推荐是有用的推荐。从这个数据可以看出，好友推荐结果的用户满意度明显高于基于协同过滤的亚马逊推荐系统。</p>
<p>不过作者也承认实验存在一些问题。其中两个主要的问题如下：</p>
<p>不是双盲实验，参试者知道什么结果来自基于协同过滤的推荐系统，什么结果来自好友的推荐；</p>
<p>参试者在实验室中的行为可能和他们平时的真实行为不同。</p>
<p>此外，上述实验结果仅仅来自对19个用户的调查，样本过小。因此，对于上面的结果不要过分解读，还是应该在自己的系统中进行AB测试，得到最为客观的答案。</p>
<h3 id="信息流推荐"><a class="header" href="#信息流推荐">信息流推荐</a></h3>
<p>信息流推荐是社会化推荐领域的新兴话题，它主要针对Twitter和Facebook这两种社交网站。在这两种社交网站中，每个用户都有一个信息墙，展示了用户好友最近的言论。这个信息墙无疑已经是个性化的，但是里面还是夹杂了很多垃圾信息。这主要是因为我们并不关心我们关注的好友的所有言论，而只关心他们的言论中和自己相关的部分。虽然我们在选择关注时已经考虑了关注对象和自己兴趣的相似度，但显然我们无法找到和自己兴趣完全一致的人。因此，信息流的个性化推荐要解决的问题就是如何进一步帮助用户从信息墙上挑选有用的信息。</p>
<p>目前最流行的信息流推荐算法是Facebook的EdgeRank，该算法综合考虑了信息流中每个会话的时间、长度与用户兴趣的相似度。EdgeRank算法比较神秘，没有相关的论文，不过Tech Crun ch曾经公开过它的主要思想。</p>
<p>不过，EdgeRank算法的个性化因素仅仅是好友的熟悉度，它并没有考虑帖子内容和用户兴趣的相似度。所以EdgeRank仅仅考虑了“我”周围用户的社会化兴趣，而没有重视“我”个人的个性化兴趣。为此，GroupLens的研究人员Jilin  Chen深入研究了信息流推荐中社会兴趣和个性化兴趣之间的关系。</p>
<h2 id="给用户推荐好友"><a class="header" href="#给用户推荐好友">给用户推荐好友</a></h2>
<p>好友关系是社会化网站的重要组成部分，如果用户的好友很稀少，就不能体验到社会化的好处。因此好友推荐是社会化网站的重要应用之一。好友推荐系统的目的是根据用户现有的好友、用户的行为记录给用户推荐新的好友，从而增加整个社交网络的稠密程度和社交网站用户的活跃度。由此可以说明，好友推荐模块已经成为社交网站的标准配置之一。</p>
<p>好友推荐算法在社交网络上被称为链接预测（link  prediction）。关于链接预测算法研究的代表文章是Jon Kleinberg的“Link Prediction in Social Network”。该文对各种用户好友关系的预测方法进行了系统地研究和对比。本章我们将介绍其中一些比较直观和简单的算法。</p>
<h3 id="基于内容的匹配"><a class="header" href="#基于内容的匹配">基于内容的匹配</a></h3>
<p>我们可以给用户推荐和他们有相似内容属性的用户作为好友。下面给出了常用的内容属性。</p>
<p>用户人口统计学属性，包括年龄、性别、职业、毕业学校和工作单位等。</p>
<p>用户的兴趣，包括用户喜欢的物品和发布过的言论等。</p>
<p>用户的位置信息，包括用户的住址、IP地址和邮编等。</p>
<p>利用内容信息计算用户的相似度和我们前面讨论的利用内容信息计算物品的相似度类似。</p>
<h3 id="基于共同兴趣的好友推荐"><a class="header" href="#基于共同兴趣的好友推荐">基于共同兴趣的好友推荐</a></h3>
<p>在Twitter和微博为代表的以兴趣图谱为主的社交网络中，用户往往不关心对于一个人是否在现实社会中认识，而只关心是否和他们有共同的兴趣爱好。因此，在这种网站中需要给用户推荐和他有共同兴趣的其他用户作为好友。</p>
<p>我们在前面介绍基于用户的协同过滤算法（UserCF）时已经详细介绍了如何计算用户之间的兴趣相似度，其主要思想就是如果用户喜欢相同的物品，则说明他们具有相似的兴趣。在新浪微博中，可以将微博看做物品，如果两个用户曾经评论或者转发同样的微博，说明他们具有相似的兴趣。在Facebook中，因为有大量用户Like（喜欢）的数据，所以更容易用UserCF算法计算用户的兴趣相似度。关于这方面的算法可以参考第3章。</p>
<p>此外，也可以根据用户在社交网络中的发言提取用户的兴趣标签，来计算用户的兴趣相似度。关于如何分析用户发言的内容、提取文本的关键词、计算文本的相似度，可以参考第4章。</p>
<h3 id="基于社交网络图的好友推荐"><a class="header" href="#基于社交网络图的好友推荐">基于社交网络图的好友推荐</a></h3>
<p>在社交网站中，我们会获得用户之间现有的社交网络图，然后可以基于现有的社交网络给用户推荐新的好友，比如可以给用户推荐好友的好友。</p>
<p>最简单的好友推荐算法是给用户推荐好友的好友。在人人网，我们经常可以通过这个功能找到很多自己的老同学。在刚开始用人人网时，我们只能加入有限的好友，因为我们记住的好友有限。虽然我们只能记住几个同学，但那些同学又能记住几个不同的同学，在这种情况下，我们可以通过朋友的朋友找到更多我们认识的人。</p>
<p>基于好友的好友推荐算法可以用来给用户推荐他们在现实社会中互相熟悉，而在当前社交网络中没有联系的其他用户。</p>
<h3 id="基于用户调查的好友推荐算法对比"><a class="header" href="#基于用户调查的好友推荐算法对比">基于用户调查的好友推荐算法对比</a></h3>
<p>对于前面3节提出的几种不同的好友推荐算法，上一节提到的GroupLen的Jilin Chen也进行了研究。他通过用户调查对比了不同算法的用户满意度，其中算法（这里我们使用了不同的命名）如下。</p>
<p>InterestBased  给用户推荐和他兴趣相似的其他用户作为好友。</p>
<p>SocialBased  基于社交网络给用户推荐他好友的好友作为好友。</p>
<p>Interest+Social 将InterestBased算法推荐的好友和SocialBased算法推荐的好友按照一定权重融合。</p>
<p>SONASONA是IBM内部的推荐算法，该算法利用大量用户信息建立了IBM员工之间的社交网络。这些信息包括所在的部门、共同发表的文章、共同写的Wiki、IBM的内部社交网络信息、共同合作的专利等。</p>
<p>然后，Jilin  Chen在IBM数据的基础上用上述算法建立4种不同的好友推荐系统，然后给每个参加测试的用户提供12个推荐结果，其中每个算法提供了3个推荐结果。也就是说，参试者并不知道每个结果来自哪个算法。然后，Jilin Chen让参试者对每个推荐结果回答以下4个问题。</p>
<p>你是否认识这个人？</p>
<p>你是否觉得这是一个好的推荐结果？</p>
<p>你是否觉得推荐理由能够帮助你决策？</p>
<p>看到这个推荐结果后你决定进行以下哪种行为（单选）：主动和这个人交朋友；希望别人能够向这个人介绍自己；什么也不干。</p>
<p>首先，从结果可以发现，对推荐结果的新颖性不同算法的排名如下：InterestBased &gt; Interest+Social &gt; SocialBased &gt; SONA</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250204115853.png" alt="" /></p>
<p>SONA因为用到了部门信息、共同写论文和发表专利的信息，所以推荐的好友大部分都是用户认识的，因此新颖度不高。</p>
<p>其次，结果表明如果用户认识推荐结果中的人，那么绝大部分用户都会觉得这是一个好的推荐结果，而如果用户不认识推荐结果中的人，绝大多数人都觉得推荐结果不好。</p>
<p>从用户认为推荐结果是否好的比例看，不同算法的排名如下：SONA &gt; SocialBased &gt; Interest+Social &gt; InterestBased</p>
<p>SONA排名不高是因为它综合了更多的信息。</p>
<h2 id="扩展阅读"><a class="header" href="#扩展阅读">扩展阅读</a></h2>
<p>社交网络分析的研究已经有很悠久的历史了。其中关于社交网络最让人耳熟能详的结论就是六度原理。六度原理讲的是社会中任意两个人都可以通过不超过6个人的路径相互认识，如果转化为图的术语，就是社交网络图的直径为6。不过喜欢刨根问底的读者一定好奇六度原理的正确性。六度原理在均匀随机图上已经得到了完美证明，对此感兴趣的读者可以参考Random Graph一书。很多对社交网络的研究都是基于随机图理论的，因此深入研究社交网络必须掌握随机图理论的相关知识。</p>
<p>社交网络研究中有两个最著名的问题。第一个是如何度量人的重要性，也就是社交网络顶点的中心度（centrality），第二个问题是如何度量社交网络中人和人之间的关系，也就是链接预测。这两个问题的研究都有着深刻的实际意义，因此得到了业界和学术界的广泛关注。对这两个问题感兴趣的读者可以参考社交网络分析方面的书。</p>
<p>对于基于社交网络的推荐算法，因为数据集的限制，最早的研究都是基于Epinion的用户信任网络的。Ma Hao在Epinion数据集上提出了很多基于矩阵分解的社会化推荐算法用来解决评分预测问题，其主要思想是在矩阵分解模型中加入正则化项，让具有社交关系的用户的隐语义向量具有比较高的相似度。</p>
<p>ACM推荐系统大会在2010年曾经举办过一个社会化推荐比赛，该比赛将社交网络看做一种上下文，希望参赛者能够利用社交网络信息提高推荐系统的性能。关注社交化推荐的读者可以关注一下该比赛最后发出的论文集。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../推荐系统实践/利用上下文信息.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../推荐系统实践/推荐系统实例.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../推荐系统实践/利用上下文信息.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../推荐系统实践/推荐系统实例.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
